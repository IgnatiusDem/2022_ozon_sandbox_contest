# 2022_ozon_sandbox_contest
Tasks from the ozon contest sandbox

# A. Сумматор 
### Входные данные
В первой строке входных данных содержится целое число t (1≤t≤104) — количество наборов входных данных в тесте.

Далее следуют описания t наборов входных данных, один набор в строке.

В первой (и единственной) строке набора записаны два целых числа a и b (−1000≤a,b≤1000).

### Выходные данные
Для каждого набора входных данных выведите сумму двух заданных чисел, то есть a+b.

# B. Сумма к оплате
В магазине акция: «купи три одинаковых товара и заплати только за два». Конечно, каждый купленный товар может участвовать лишь в одной акции. Акцию можно использовать многократно.

Например, если будут куплены 7 товаров одного вида по цене 2 за штуку и 5 товаров другого вида по цене 3 за штуку, то вместо 7⋅2+5⋅3 надо будет оплатить 5⋅2+4⋅3=22.

Считая, что одинаковые цены имеют только одинаковые товары, найдите сумму к оплате.

### Входные данные
В первой строке записано целое число t (1≤t≤104) — количество наборов входных данных.

Далее записаны наборы входных данных. Каждый начинается строкой, которая содержит n (1≤n≤2⋅105) — количество купленных товаров. Следующая строка содержит их цены p1,p2,…,pn (1≤pi≤104). Если цены двух товаров одинаковые, то надо считать, что это один и тот товар.

Гарантируется, что сумма значений n по всем тестам не превосходит 2⋅105.

### Выходные данные
Выведите t целых чисел — суммы к оплате для каждого из наборов входных данных.

### Пример
### Входные данные
```
6
12
2 2 2 2 2 2 2 3 3 3 3 3
12
2 3 2 3 2 2 3 2 3 2 2 3
1
10000
9
1 2 3 1 2 3 1 2 3
6
10000 10000 10000 10000 10000 10000
6
300 100 200 300 200 300
```
### Выходные данные
```
22
22
10000
12
40000
1100
```
# C. Парное программирование
В компании работает n разработчиков, где n — четное число. Менеджер решил разбить всех разработчиков на команды по два человека.

Для этого он составил список всех разработчиков и назначил каждому из них номер по списку (от 1 до n) и значение ai — уровень мастерства i-го в списке разработчика.

Очередную команду он составляет следующим образом:

- первый разработчик в команде тот, кто идет первым в списке;
- ему в пару подбирается такой, что разница их уровней минимальна (то есть минимально значение |ai−aj|, где |x| — это модуль числа x); если таких кандидатов несколько, - то выбирается из них тот, кто находится раньше в списке;
- эти два разработчика образуют команду и удаляются из списка.
Например, если массив a равен [2,1,3,1,1,4], то формирование команд будет происходить следующим образом:

- назначим разработчикам номера [1,2,3,4,5,6] в соответствии с их положением в списке, первый среди них имеет номер 1, его уровень мастерства a1=2, подходящими (с минимальной абсолютной разностью) являются разработчики с номерами 2,3,4,5, первый среди них 2, таким образом первая команда — это разработчики с номерами 1 и 2;
- оставшиеся разработчики теперь имеют номера [3,4,5,6], первый среди них 3, его уровень a3=3, разработчик с минимальной абсолютной разностью только один (номер 6), таким образом команда — разработчики с номерами 3 и 6;
- оставшиеся разработчики имеют номера [4,5], первый среди них 4, его уровень a4=1, остался только разработчик с номером 5, таким образом третья команда — разработчики с номерами 4 и 5.

Ваша задача — помочь менеджеру промоделировать процесс разбиения на команды. Обратите внимание, что команды должны быть выведены в порядке, описанном выше в условии.

### Входные данные
Первая строка содержит одно целое число t (1≤t≤50) — количество наборов входных данных.

Первая строка каждого набора содержит одно целое число n (2≤n≤50; n четное) — количество разработчиков.

Вторая строка содержит n целых чисел a1,a2,…,an (1≤ai≤100), где ai — уровень мастерства i-го разработчика.

### Выходные данные
Для каждого набора входных данных выведите n/2 строк, i-я строка должна содержать пару чисел — номер первого и второго разработчика в i-й команде в порядке, описанном в условии.

Выводите пустую строку между выводами для наборов входных данных.

### Пример
### Входные данные
```
3
6
2 1 3 1 1 4
2
5 5
8
1 4 2 5 4 2 6 3
```
### Выходные данные
```
1 2
3 6
4 5

1 2

1 3
2 5
4 7
6 8
```
# D. Отчет
Директор IT-корпорации оценивает эффективность работы сотрудников по различным показателям и критериям. Один из этих критериев сформулирован следующим образом: приступив к некоторому заданию, сотрудник должен завершить его, не переключаясь на другие задания.

Чтобы проверить сотрудников на соответствие этому критерию, директор потребовал от каждого сотрудника отчет о том, какие задания он выполнял в последние n дней. Отчет — это последовательность из n целых чисел a1,a2,…,an, где ai — идентификатор задания, которое сотрудник выполнял в i-й день.

Вам необходимо написать программу, проверяющую, соответствует ли сотрудник критерию по его отчету. Сотрудник соответствует этому критерию, если не существует такого задания x, которое выполнялось с перерывом (т. е. в некоторый день i сотрудник выполнял задание x, в дни с i+1 по j−1 он занимался другими заданиями, а в день j сотрудник продолжил выполнение задания x, при этом j>i+1). Иными словами, каждое задание, которое выполнял сотрудник, должно занимать один непрерывный отрезок дней.

### Входные данные
В первой строке задано одно целое число t (1≤t≤10) — количество наборов входных данных.

Каждый набор входных данных состоит из двух строк. В первой строке задано одно целое число n (3≤n≤50000). Во второй строке заданы n целых чисел a1,a2,…,an (1≤ai≤n) — отчет сотрудника.

### Выходные данные
Для каждого набора входных данных выведите ответ на отдельной строке. Если отчет соответствует критерию, выведите YES, иначе выведите NO.

### Пример
### Входные данные
```
5
5
1 2 3 4 5
4
1 2 3 1
8
2 3 4 8 5 5 5 5
5
1 1 3 2 2
5
1 1 2 3 2
```
### Выходные данные
```
YES
NO
YES
YES
NO
```
# E. Отрезки времени
Вам задан набор отрезков времени. Каждый отрезок задан в формате HH:MM:SS-HH:MM:SS, то есть сначала заданы часы, минуты и секунды левой границы отрезка, а затем часы, минуты и секунды правой границы.

Вам необходимо выполнить валидацию заданного набора отрезков времени. Иными словами, вам нужно проверить следующие условия:

- часы, минуты и секунды заданы корректно (то есть часы находятся в промежутке от 0 до 23, а минуты и секунды — в промежутке от 0 до 59);
- левая граница отрезка находится не позже его правой границы (но границы могут быть равны);
- никакая пара отрезков не пересекается (даже в граничных моментах времени).

Вам необходимо вывести YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае.

Вам необходимо ответить на t независимых наборов тестовых данных.

### Входные данные
Первая строка входных данных содержит одно целое число t (1≤t≤10) — количество наборов тестовых данных. Затем следуют t наборов.

Первая строка набора содержит одно целое число n (1≤n≤2⋅104) — количество отрезков времени. В следующих n строках следуют описания отрезков.

Описание отрезка времени задано в формате HH:MM:SS-HH:MM:SS, где HH, MM и SS — последовательности из двух цифр. Заметьте, что никаких пробелов в описании формата нет. Также ни в одном описании нет пробелов в начале и конце строки.

### Выходные данные
Для каждого набора тестовых данных выведите ответ — YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае. Ответы выводите в порядке следования наборов во входных данных.

### Пример
### Входные данные
```
6
1
02:46:00-03:14:59
2
23:59:59-23:59:59
00:00:00-23:59:58
2
23:59:58-23:59:59
00:00:00-23:59:58
2
23:59:59-23:59:58
00:00:00-23:59:57
6
17:53:39-20:20:02
10:39:17-11:00:52
08:42:47-09:02:14
09:44:26-10:21:41
00:46:17-02:07:19
22:42:50-23:17:46
1
24:00:00-23:59:59
```
### Выходные данные
```
YES
YES
NO
NO
YES
NO
```
# E. Возможные друзья
Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей. Помимо этого, часто существует система рекомендации друзей, которая показывает пользователям людей, с которыми они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей. Вам предстоит разработать систему рекомендации друзей.

В интересующей нас социальной сети n пользователей, каждому из которых присвоен уникальный id от 1 до n. У каждого пользователя этой сети не более 5 друзей. Очевидно, ни один пользователь не является другом самому себе, и если пользователь x в списке друзей у пользователя y, то и пользователь y входит в список друзей пользователя x.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя x в список должны входить такие пользователи y, что:
- y не является другом x и не совпадает с x;
- у пользователя y и у пользователя x есть хотя бы один общий друг;
- не существует такого пользователя y′, который удовлетворяет первым двум ограничениям, и у которого строго больше общих друзей с x, чем у y с x.

Иными словами, в список возможных друзей пользователя x входят все такие пользователи, не являющиеся его друзьями, для которых количество общих друзей с x максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.

### Входные данные
В первой строке заданы два целых числа n и m — количество пользователей и количество пар друзей, соответственно.

Далее следуют m строк, в каждой из которых заданы два целых числа xi и yi (1≤xi,yi≤n; xi≠yi) — очередная пара друзей в социальной сети. Каждая пара друзей задается не более одного раза; у каждого пользователя не более 5 друзей.

### Выходные данные
Для каждого пользователя от 1 до n выведите в отдельной строке список его возможных друзей в следующем формате:
- если список возможных друзей пуст, выведите одно целое число 0;
- иначе выведите id возможных друзей пользователя в возрастающем порядке.

### Пример
### Входные данные
```
8 6
4 3
3 1
1 2
2 4
2 5
6 8
```
### Выходные данные
```
4
3
2
1
1 4
0
0
0
```
### Входные данные
```
8 10
1 2
1 3
1 4
4 3
3 2
2 4
1 8
5 6
7 6
5 7
```
### Выходные данные
```
0
8
8
8
0
0
0
2 3 4
```
### Примечание
Рассмотрим первый пример из условия.

Для начала сформируем списки друзей всех пользователей:
- друзья пользователя 1: [2,3].
- друзья пользователя 2: [1,4,5].
- друзья пользователя 3: [1,4].
- друзья пользователя 4: [2,3].
- друзья пользователя 5: [2].
- друзья пользователя 6: [8].
- друзья пользователя 7: [] (список друзей пуст).
- друзья пользователя 8: [6].

Рассмотрим, как формируются списки возможных друзей для некоторых пользователей.

У пользователя 1 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 4 (общие друзья 2 и 3) и пользователь 5 (общий друг 2). С пользователем 4 общих друзей больше, поэтому в список возможных друзей попадает только он.

У пользователя 5 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 1 (общий друг 2) и пользователь 4 (общий друг 2). Количество общих друзей одинаковое, поэтому оба этих пользователя попадают в список возможных друзей.

У пользователя 7 вообще нет друзей, поэтому ни один пользователь не удовлетворяет требованиям списка возможных друзей.
# G. Валидация карты
В этой задаче вам необходимо реализовать валидацию корректности карты для стратегической компьютерной игры.

Карта состоит из гексагонов (шестиугольников), каждый из которых принадлежит какому-то региону карты. В файлах игры карта представлена как n строк по m символов в каждой (строки и символы в них нумеруются с единицы). Каждый нечетный символ каждой четной строки и каждый четный символ каждой нечетной строки — точка (символ . с ASCII кодом 46); все остальные символы соответствуют гексагонам и являются заглавными буквами латинского алфавита. Буква указывает на то, какому региону принадлежит гексагон.

Посмотрите на картинку ниже, чтобы понять, как описание карты в файлах игры соответствует карте из шестиугольников.

![image](https://user-images.githubusercontent.com/105270743/188126410-0a15bd37-c1d7-4b8c-b254-994d974e5fa8.png)

Соответствие описания карты в файле (слева) и самой карты (справа). Регионы R, G, V, Y и B окрашены в красный, зеленый, фиолетовый, желтый и синий цвет, соответственно.

Вы должны проверить, что каждый регион карты является одной связной областью. Иными словами, не должно быть двух гексагонов, принадлежащих одному и тому же региону, которые не соединены другими гексагонами этого же региона.

![image](https://user-images.githubusercontent.com/105270743/188126739-5f293fe0-caa5-474c-bc55-332e8f7c87cc.png)

Карта слева является корректной. Карта справа не является корректной, так как гексагоны, обозначенные цифрами 1 и 2, принадлежат одному и тому же региону (обозначенному красным цветом), но не соединены другими гексагонами этого региона.

### Входные данные
В первой строке задано одно целое число t (1≤t≤100) — количество наборов входных данных.

Первая строка набора входных данных содержит два целых числа n и m (2≤n,m≤20) — количество строк и количество символов в каждой строке в описании карты.

Далее следуют n строк по m символов в каждой — описание карты. Каждый нечетный символ каждой четной строки и каждый четный символ каждой нечетной строки — точка (символ . с ASCII кодом 46); все остальные символы соответствуют гексагонам и являются заглавными буквами латинского алфавита.

### Выходные данные
На каждый набор входных данных выведите ответ в отдельной строке — YES, если каждый регион карты представляет связную область, или NO, если это не так.

### Пример
### Входные данные
```
3
3 7
R.R.R.G
.Y.G.G.
B.Y.V.V
4 8
Y.R.B.B.
.R.R.B.V
B.R.B.R.
.B.B.R.R
2 7
G.B.R.G
.G.G.G.
```
### Выходные данные
```
YES
NO
YES
```
### Примечание
Первые два набора входных данных из примера показаны на второй картинке в условии.

# H. Планировщик задач
Представьте, вы собрали собственный сервер из n разнородных процессоров и теперь решили создать для него простейший планировщик задач.

Ваш сервер состоит из n процессоров. Но так как процессоры разные, то и достигают они одинаковой скорости работы при разном энергопотреблении. А именно, i-й процессор в нагрузке тратит ai энергии за одну секунду.

Вашему серверу в качестве тестовой нагрузки придет m задач. Про каждую задачу вам известны два значения: tj и lj — момент времени, когда задача j придет и время выполнения задачи в секундах.

Для начала вы решили реализовать простейший планировщик, ведущий себя следующим образом: в момент tj прихода задачи, вы выбираете свободный процессор с минимальным энергопотреблением и выполняете данную задачу на выбранном процессоре все заданное время. Если к моменту прихода задачи свободных процессоров нет, то вы просто отбрасываете задачу.

Процессор, на котором запущена задача j будет занят ровно lj секунд, то есть освободится ровно в момент tj+lj и в этот же момент уже может быть назначен для выполнения какой-то другой задачи.

Определите суммарное энергопотребление вашего сервера при обработке m заданных задач (будем считать, что процессоры в простое не потребляют энергию).

### Входные данные
В первой строке заданы два целых числа n и m (1≤n,m≤3⋅105) — количество процессоров и задач соответственно.

Во второй строке заданы n целых чисел a1,a2,…,an (1≤ai≤106) — энергопотребление соответствующих процессоров под нагрузкой в секунду. Все энергопотребления различны.

В следующих m строках заданы описания задач: по одному в строке. В j-й строке заданы два целых числа tj и lj (1≤tj≤109; 1≤lj≤106) — момент прихода j-й задачи и время ее выполнения.
Все времена прихода tj различны, и задачи заданы в порядке времени прихода.
### Выходные данные
Выведите единственное число — суммарное энергопотребление сервера, если потреблением энергии в простое можно пренебречь.

### Пример
### Входные данные
```
4 7
3 2 6 4
1 3
2 5
3 7
4 10
5 5
6 100
9 2
```
### Выходные данные
```
105
```
### Примечание
Рассмотрим работу планировщика по секундно:

- t=1: приходит первая задача, все процессоры свободны. Задача занимает второй процессор на 3 секунды.
- t=2: приходит вторая задача. Второй процессор занят, а потому задача занимает первый процессор на 5 секунд.
- t=3: приходит третья задача и занимает четвертый процессор на 7 секунд.
- t=4: приходит четвертая задача. Второй процессор освободился в данный момент, а потому его и занимает задача на 10 секунд.
- t=5: приходит пятая задача и занимает последний свободный на данный момент процессор (третий) на 5 секунд.
- t=6: приходит шестая задача. Все процессоры еще заняты, а потому задача отбрасывается.
- t=7: освобождается первый процессор.
- t=9: приходит седьмая задача и занимает первый процессор на 2 секунды.
- t=10: освобождаются третий и четвертый процессоры.
- t=11: освобождается первый процессор.
- t=14: освобождается второй процессор.

Общее энергопотребление равно 3⋅2 + 5⋅3 + 7⋅4 + 10⋅2 + 5⋅6 + 2⋅3 = 6+15+28+20+30+6 = 105.

# I. Рифмы
Вы разрабатываете программу автоматической генерации стихотворений. Один из модулей этой программы должен подбирать рифмы к словам из некоторого словаря.

Словарь содержит n различных слов. Словами будем называть последовательности из 1—10 строчных букв латинского алфавита.

Зарифмованность двух слов — это длина их наибольшего общего суффикса (суффиксом будем называть какое-то количество букв в конце слова). Например:

- task и flask имеют зарифмованность 3 (наибольший общий суффикс — ask);
- decide и code имеют зарифмованность 2 (наибольший общий суффикс — de);
- id и void имеют зарифмованность 2 (наибольший общий суффикс — id);
- code и forces имеют зарифмованность 0.

Ваша программа должна обработать q запросов следующего вида: дано слово ti (возможно, принадлежащее словарю), необходимо найти слово из словаря, которое не совпадает с ti и имеет максимальную зарифмованность с ti среди всех слов словаря, не совпадающих с ti. Если подходящих слов несколько — выведите любое из них.

### Входные данные
Первая строка содержит одно целое число n (2≤n≤50000) — размер словаря.

Далее следуют n строк, i-я строка содержит одну строку si (1≤|si|≤10) — i-е слово из словаря. В словаре все слова различны.

Следующая строка содержит одно целое число q (1≤q≤50000) — количество запросов.

Далее следуют q строк, i-я строка содержит одну строку ti (1≤|ti|≤10) — i-й запрос.

Каждая строка si и каждая строка ti состоит только из строчных букв латинского алфавита.

### Выходные данные
Для каждого запроса выведите одну строку — слово из словаря, которое не совпадает с заданным в запросе и имеет с ним максимальную зарифмованность (если таких несколько — выведите любое).

### Пример
### Входные данные
```
3
task
decide
id
6
flask
code
void
forces
id
ask
```
### Выходные данные
```
task
decide
id
task
decide
task
```
